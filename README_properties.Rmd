---
title: 'Properties of applied functions'
output: md_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  comment = NA,
  tidy = TRUE
  )
library(tidyverse)
```

The used functions do not behave equal for all parameter settings. 
Examples are provided for the commutativity and the transitive law.
This affects for example the cardinality of the joined sets.
Moreover, if the distribution of the combinations within a set is studied, it should be taken into account if each feature is counted or each combination (e.g. $A=\{(a_{1},b_{1}),(a_{1},b_{2})\}$).


## Laws to consider for bedtools closest
```{bash, echo=TRUE}
cat A.bed
```
```{bash, echo=TRUE}
cat B.bed
```

### Commutative property

The nearest neighbor function is not commutative for all parameter settings.

```{bash, echo=TRUE}
bedtools closest -D a -a A.bed -b B.bed
```


```{bash, echo=TRUE}
bedtools closest -D a -a B.bed -b A.bed
```

Therefore it is necessary to consider the symmetry of the used parameters.
For example by using `ignore overlap`, `ignore downstream` and `ignore upstream`,
```{bash, echo=TRUE}
bedtools closest -D a -io -iu -a A.bed -b B.bed
```


```{bash, echo=TRUE}
bedtools closest -D a -io -id -a B.bed -b A.bed
```

or by enumerating the complete environment of a feature.

```{bash, echo=TRUE}
bedtools closest -D a -k 2 -a A.bed -b B.bed
```


```{bash, echo=TRUE}
bedtools closest -D a -k 2 -a B.bed -b A.bed
```



## Properties and behaviour of dplyr::full_join

### Commutative property

A non-commutative parameter setting may lead to inconsistent results.
In the second example, we used a not suitable parameter setting.
The obtained set $A$ is then ambiguous:
$a_{2}\rightarrow b_{2}$ and $a_{2}\rightarrow NA$. 

```{r, echo=TRUE}
AB <- data.frame(A = c("a1", "a2"), B = c("b1", "b2"))
BA <- data.frame(B = c("b1", "b2"), A = c("a1", "a2"))
full_join(AB, BA)
```

```{r, echo=TRUE}
AB <- data.frame(A = c("a1", "a2"), B = c("b1", "b2"))
BA <- data.frame(B = c("b1", NA), A = c("a1", "a2"))
full_join(AB, BA)
```


## Transitive relation
The same applies to transitivity: if ($a_{1}$, $b_{1}$) and ($b_{1}$, $c_{1}$) were determined as joint occurred, ($a_{1}$, $c_{1}$) should be implied. 
If that is not true, multiple combinations are obtained in the union.

```{r, echo=TRUE}
AB <- data.frame(A = c("a1", "a2"), B = c("b1", "b2"))
BA <- data.frame(B = c("b1", "b2"), A = c("a1", "a2"))
AC <- data.frame(A = c("a1", "a2"), C = c("c1", "c2"))
CA <- data.frame(C = c("c1", "c2"), A = c("a1", "a2"))

BC <- data.frame(B = c("b1", "b2"), C = c("c1", "c2"))
CB <- data.frame(C = c("c1", "c2"), B = c("b1", "b2"))

AB_ <- full_join(AB, BA)
AC_ <- full_join(AC, CA)
A <- full_join(AB_, AC_)

BC_ <- full_join(BC, CB)
BA_ <- full_join(BA, AB)
B <- full_join(BA_, BC_)

full_join(A, B)
```



```{r}
AB <- data.frame(A = c("a1", "a2"), B = c("b1", "b2"))
BA <- data.frame(B = c("b1", "b2"), A = c("a1", "a2"))
AC <- data.frame(A = c("a1", "a2"), C = c("c1", NA))
CA <- data.frame(C = c("c1", NA), A = c("a1", "a2"))

BC <- data.frame(B = c("b1", "b2"), C = c("c1", "c2"))
CB <- data.frame(C = c("c1", "c2"), B = c("b1", "b2"))

AB_ <- full_join(AB, BA)
AC_ <- full_join(AC, CA)
A <- full_join(AB_, AC_)

BC_ <- full_join(BC, CB)
BA_ <- full_join(BA, AB)
B <- full_join(BA_, BC_)

full_join(A, B)
```

